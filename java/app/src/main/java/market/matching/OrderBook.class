// Source code is decompiled from a .class file using FernFlower decompiler (from Intellij IDEA).
package market;

import java.util.Comparator;
import java.util.Iterator;
import java.util.PriorityQueue;
import java.util.UUID;
import market.orders.Order;
import market.orders.OrderSide;
import market.orders.OrderValidator;
import market.orders.PricedOrder;

public class OrderBook {
   private final Comparator<PricedOrder> bidComparator = Comparator.comparing(PricedOrder::getPrice).reversed().thenComparing(Order::getTimestamp);
   private final Comparator<PricedOrder> offerComparator = Comparator.comparing(PricedOrder::getPrice).thenComparing(Order::getTimestamp);
   private final PriorityQueue<PricedOrder> bids;
   private final PriorityQueue<PricedOrder> offers;

   public OrderBook() {
      this.bids = new PriorityQueue(this.bidComparator);
      this.offers = new PriorityQueue(this.offerComparator);
   }

   public PricedOrder getBestBid() {
      return (PricedOrder)this.bids.peek();
   }

   public PricedOrder getBestOffer() {
      return (PricedOrder)this.offers.peek();
   }

   public boolean isEmpty() {
      return this.bids.size() == 0 && this.offers.size() == 0;
   }

   public int getNumOffers() {
      return this.offers.size();
   }

   public int getNumBids() {
      return this.bids.size();
   }

   public PricedOrder getBestOrder(OrderSide side) {
      PricedOrder var10000;
      switch (side) {
         case BUY:
            var10000 = this.getBestBid();
            break;
         case SELL:
            var10000 = this.getBestOffer();
            break;
         default:
            throw new IllegalArgumentException("Order side '" + side.toString() + "' is not known");
      }

      return var10000;
   }

   public void insertRestingOrder(PricedOrder order) {
      this.getHeapOfSide(order.getSide()).add(order);
   }

   public boolean cancelOrder(UUID orderId, OrderSide side) {
      PriorityQueue<PricedOrder> sideHeap = this.getHeapOfSide(side);
      return sideHeap.removeIf((o) -> {
         return o.getOrderId().equals(orderId);
      });
   }

   public boolean amendOrderVolume(UUID orderId, OrderSide side, int newVolume) {
      OrderValidator.validateVolume(newVolume);
      PriorityQueue<PricedOrder> relevantHeap = this.getHeapOfSide(side);
      Iterator var6 = relevantHeap.iterator();

      while(var6.hasNext()) {
         PricedOrder o = (PricedOrder)var6.next();
         if (o.getOrderId().equals(orderId)) {
            relevantHeap.remove(o);
            o.setVolume(newVolume);
            relevantHeap.add(o);
            return true;
         }
      }

      return false;
   }

   public Trade tradeTop(PricedOrder order, int volumeToTrade) {
      PricedOrder best = this.getBestOrder(order.getSide());
      if (best == null) {
         throw new OrderNotFoundException("No orders to trade with found");
      } else {
         if (best.getVolume() == volumeToTrade) {
            this.cancelOrder(best.getOrderId(), best.getSide());
         } else {
            this.amendOrderVolume(best.getOrderId(), order.getInverseSide(), best.getVolume() - volumeToTrade);
         }

         UUID bidderId;
         UUID offererId;
         switch (order.getSide()) {
            case BUY:
               bidderId = order.getOrderId();
               offererId = best.getOrderId();
               break;
            case SELL:
               offererId = order.getOrderId();
               bidderId = order.getOrderId();
               break;
            default:
               throw new IllegalArgumentException("Order side '" + order.getSide().toString() + "' is not known");
         }

         return new Trade(offererId, bidderId, best.getPrice(), volumeToTrade);
      }
   }

   private PriorityQueue<PricedOrder> getHeapOfSide(OrderSide side) {
      PriorityQueue var10000;
      switch (side) {
         case BUY:
            var10000 = this.bids;
            break;
         case SELL:
            var10000 = this.offers;
            break;
         default:
            throw new IllegalArgumentException("Order side '" + side.toString() + "' is not known");
      }

      return var10000;
   }
}
